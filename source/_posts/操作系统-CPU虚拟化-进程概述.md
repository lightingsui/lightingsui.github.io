---
title: 操作系统-CPU虚拟化-进程概述
date: 2021-02-02 14:09:31
tags: 虚拟化CPU
categories: 操作系统
---
# 操作系统-CPU虚拟化-进程概述

目前，大多数人对进程的概念就是一个运行的程序，这个讲法从广义上来说是正确的。一个运行的进程无非就是频繁的从内存中取指令，然后执行，往复循环，直到执行完程序，最后关闭进程。

我们想让CPU一次执行多个程序，就需要让许多进程共享一个CPU，这就是时分共享技术，通过时分共享技术，每个进程执行一个CPU的时间片，当时间片到了，进行上下文切换，然后CPU执行其他的进程，但是这样做会损失一些性能，频繁的进行上下文切换必定会损失CPU的效率。

> 所谓的时分共享技术就是将CPU的时间进行划分，第一个时间片执行A进程，A进程的时间片结束，将执行CPU的第二个时间片，这样CPU就被许多进程按时间进行了划分。
>
> 有时分共享技术，就存在着空分共享技术。空分共享技术的含义为许多进程使用着一个大的空间，一旦某个空间分配给某个进程，那么其他进程就不允许访问，也不允许修改。

时分共享技术存在着一个问题，如何确定某个进程的执行顺序，或者小一点的说就是CPU怎么知道先执行哪个进程，后执行哪个进程。这就要取决于算法了，这个算法就是CPU调度算法，它控制着进程得到CPU执行的顺序，我们会在以后的模块中专门总结进程调度算法，它也是操作系统中的重要知识点。

正在执行的程序无时无刻不在访问内存，指令存在内存中，正在读取以及写入的操作也在内存中，可见内存对于操作系统是多么的重要，另外对进程很重要的就是各种寄存器，包括指令寄存器、程序计数器以及栈指针和针指针

> 这里介绍一下机制与策略，机制主要就是实现功能，即能提供完整的解决方案，例如在操作系统中，机制提供的基本作用就是可以执行进程，更高一层的就是策略，策略主要为"哪个"，例如在操作系统中，进程调度算法就是一种策略，它选择一个进程，然后让底层的机制执行。
>
> 通过这样的分层，可以将软件很好的解耦，在软件设计中是重要的一环

## 进程API

在了解进程API之前，先了解一下关于进程API的分类

+ 创建，该类API的作用主要就是创建新进程。
+ 销毁，主要用于销毁进程，主要用于想中途退出进程的应用（一般的进程在执行完毕之后会自动退出进程）
+ 等待，主要用于等待进程的停止，例如父进程调用wait等待子进程结束
+ 其他控制，例如许多操作系统提供API来暂停进程
+ 状态，获取进程的当前执行状态信息，例如进程执行了多长时间。

### 预备知识

操作系统如何运行一个程序？操作系统首先将**程序的代码**以及**静态数据**从持久化的存储设备中**加载到内存**的特定区域，这些程序的代码以及静态数据在进程没有执行之前是放在硬盘或某种持久性的存储设备中。早期的操作系统会一次性的将程序执行所需要的所有数据一次性的加载到内存中，这会给内存造成严重的压力，现代的操作系统会进行懒加载（延迟加载），只加载程序执行时需要的部分数据，如果以后程序在执行的时候需要其它的数据，再到硬盘中进行加载。

<img src="https://raw.githubusercontent.com/lightingsui/Pic/master/img/20210128220622.png" style="zoom:50%;" />

其次，操作系统必须为程序的运行时栈分配一些内存，程序的运行栈中包括局部变量、函数的参数以及返回地址。操作系统分配这些内存，提供给进程使用，操作系统也可能会用参数初始化栈，具体一点，就是将参数填入main函数，即argc和argv数组。

然后，操作系统为程序的堆分配内存，堆中主要存放了程序运行时动态请求分配的内存，在c语言中，主要就是通过malloc请求的，在不使用这部分申请的内存时，调用free释放内存，在free时，只传入了内存的开始地址，并没有传入之前请求空间的大小，因此，在申请内存的时候，就需要有一个专门的数据结构记录申请的空间的大小。

> 堆和栈在大多数操作系统中是可以在运行时扩展的，内存不足时，操作系统可以请求硬件进行扩展，栈是向小地址空间进行扩展，而堆是向大地址空间进行扩展

最后，还将要执行一些关于IO的初始化工作，例如在UNIX中，操作系统为每个进程打开3个文件描述符（file descriptor），用于标准输入、输出、错误。用于从终端读取内容和将内容打印到屏幕。

进行了这些初始化的工作，接下来OS会将CPU的使用权和控制权交给该进程。

## 进程的状态

我们上面已经了解了一个进程要执行时操作系统要做的大概步骤，那么接下来就应该了解一下进程都有哪些状态

### 三态模型

三态模型为进程状态的基本模型，包含了就绪态、运行态、阻塞态

![](https://raw.githubusercontent.com/lightingsui/Pic/master/img/20210202114451.png)

**就绪态：**进程由于没有得到CPU的时间片或者其他原因使进程处于就绪态，此时进程还没有运行

**运行态：**此时进程得到CPU的时间片，并且从就绪态转变过来，进程正在CPU上执行

**阻塞态：**在阻塞状态下，一个进程执行了某种操作，例如执行了IO请求，当IO请求结束后，进程就会变为就绪态或者从就绪态直接转移到运行态（这取决于进程调度，具有不确定性）

### 五态模型

在基本的三态模型下，引入了更加详细的五态模型，用来描述更加复杂的进程状态转换

在三态模型的基础上，加入了新建态和终止态

![](https://raw.githubusercontent.com/lightingsui/Pic/master/img/20210202115648.png)

**新建态：**进程被刚刚创建，还不能运行

**终止态：**进程运行已经结束，回收除进程控制块之外的其他资源

进程的另外一些状态包括已退出但未清理状态（在Linux中称为僵尸进程），这个状态非常有用，他可以用来检测一个命令是否执行成功，如果执行成功将返回0，执行不成功将返回非0数字，另外父子进程中，父进程通过调用wait来等待子进程执行完毕（将在下一篇总结中详解wait），并且告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构

## 数据结构

操作系统是一个程序，他和其他程序一样，需要一些关键的数据结构来跟踪各种相关的信息。

他为每个就绪态的进程创建进程列表用来保留其信息，又要通过数据结构跟踪每个正在运行的进程的信息，另外还得跟踪被阻塞的进程。

操作系统中一个重要的数据结构就是进程列表，任何能够同时运行许多进程的操作系统都应该有它，以便跟踪系统中所有正在运行的程序，将存储关于进程的个体结构称之为进程控制块（Process Control Block，PCB）

## 总结

本篇总结了虚拟化CPU的概念，并且解释了一下时分共享技术与空分共享技术。还说明了一个进程要执行，操作系统都需要执行哪些步骤，又从进程的状态开始，分别阐述了五态模型和三态模型，最后指明了操作系统中无处不在的数据结构。

下一篇基于本篇的进程API分类，逐一列出进程的部分API。
